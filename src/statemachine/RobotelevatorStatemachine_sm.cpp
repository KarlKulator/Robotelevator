//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : RobotelevatorStatemachine.sm
//

#include "RobotelevatorStatemachine.h"
#include "RobotelevatorStatemachine_sm.h"

using namespace statemap;

// Static class declarations.
MainMap_Parked MainMap::Parked("MainMap::Parked", 0);
MainMap_MovingDownTo2ndFloor MainMap::MovingDownTo2ndFloor("MainMap::MovingDownTo2ndFloor", 1);
MainMap_WaitingForRobotExit2ndFloorRobotDocked MainMap::WaitingForRobotExit2ndFloorRobotDocked("MainMap::WaitingForRobotExit2ndFloorRobotDocked", 2);
MainMap_WaitingForRobotExit2ndFloorRobotUndocked MainMap::WaitingForRobotExit2ndFloorRobotUndocked("MainMap::WaitingForRobotExit2ndFloorRobotUndocked", 3);
MainMap_Cleaning2ndFloor MainMap::Cleaning2ndFloor("MainMap::Cleaning2ndFloor", 4);
MainMap_WaitingForRobotEnter2ndFloorRobotDocked MainMap::WaitingForRobotEnter2ndFloorRobotDocked("MainMap::WaitingForRobotEnter2ndFloorRobotDocked", 5);
MainMap_MovingDownTo1stFloor MainMap::MovingDownTo1stFloor("MainMap::MovingDownTo1stFloor", 6);
MainMap_WaitingForRobotExit1stFloorRobotDocked MainMap::WaitingForRobotExit1stFloorRobotDocked("MainMap::WaitingForRobotExit1stFloorRobotDocked", 7);
MainMap_WaitingForRobotExit1stFloorRobotUndocked MainMap::WaitingForRobotExit1stFloorRobotUndocked("MainMap::WaitingForRobotExit1stFloorRobotUndocked", 8);
MainMap_Cleaning1stFloor MainMap::Cleaning1stFloor("MainMap::Cleaning1stFloor", 9);
MainMap_WaitingForRobotEnter1stFloorRobotDocked MainMap::WaitingForRobotEnter1stFloorRobotDocked("MainMap::WaitingForRobotEnter1stFloorRobotDocked", 10);
MainMap_MovingUpToParkingPosition MainMap::MovingUpToParkingPosition("MainMap::MovingUpToParkingPosition", 11);

void RobotelevatorStatemachineState::carrierButtonPressed1stFloor(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::carrierButtonPressed2ndFloor(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::carrierButtonPressedParkingPosition(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::dockingTimePassed(RobotelevatorStatemachineContext& context, int dockingtimerId)
{
    Default(context);
}

void RobotelevatorStatemachineState::robotButtonPressed1stFloor(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::robotButtonPressed2ndFloor(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::robotButtonReleased1stFloor(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::robotButtonReleased2ndFloor(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::startCleanupFirstFloor(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::startCleanupSecondFloor(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::undockingTimePassed(RobotelevatorStatemachineContext& context, int undockingtimerId)
{
    Default(context);
}

void RobotelevatorStatemachineState::Default(RobotelevatorStatemachineContext& context)
{
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "TRANSITION   : Default"
            << std::endl;
    }

    throw (
        TransitionUndefinedException(
            context.getState().getName(),
            context.getTransition()));

}

void MainMap_Parked::Default(RobotelevatorStatemachineContext& context)
{

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::Parked"
                << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::Parked::Default()"
            << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "EXIT TRANSITION : MainMap::Parked::Default()"
            << std::endl;
    }


}

void MainMap_Parked::startCleanupFirstFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::Parked"
                << std::endl;
    }

    context.getState().Exit(context);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::Parked::startCleanupFirstFloor()"
            << std::endl;
    }

    context.clearState();
    try
    {
        ctxt.moveDown();
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::Parked::startCleanupFirstFloor()"
                << std::endl;
        }

        context.setState(MainMap::MovingDownTo1stFloor);
    }
    catch (...)
    {
        context.setState(MainMap::MovingDownTo1stFloor);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_Parked::startCleanupSecondFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::Parked"
                << std::endl;
    }

    context.getState().Exit(context);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::Parked::startCleanupSecondFloor()"
            << std::endl;
    }

    context.clearState();
    try
    {
        ctxt.moveDown();
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::Parked::startCleanupSecondFloor()"
                << std::endl;
        }

        context.setState(MainMap::MovingDownTo2ndFloor);
    }
    catch (...)
    {
        context.setState(MainMap::MovingDownTo2ndFloor);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_MovingDownTo2ndFloor::Default(RobotelevatorStatemachineContext& context)
{

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::MovingDownTo2ndFloor"
                << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::MovingDownTo2ndFloor::Default()"
            << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "EXIT TRANSITION : MainMap::MovingDownTo2ndFloor::Default()"
            << std::endl;
    }


}

void MainMap_MovingDownTo2ndFloor::carrierButtonPressed2ndFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::MovingDownTo2ndFloor"
                << std::endl;
    }

    context.getState().Exit(context);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::MovingDownTo2ndFloor::carrierButtonPressed2ndFloor()"
            << std::endl;
    }

    context.clearState();
    try
    {
        ctxt.stop();
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::MovingDownTo2ndFloor::carrierButtonPressed2ndFloor()"
                << std::endl;
        }

        context.setState(MainMap::WaitingForRobotExit2ndFloorRobotDocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotExit2ndFloorRobotDocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotExit2ndFloorRobotDocked::Default(RobotelevatorStatemachineContext& context)
{

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotExit2ndFloorRobotDocked"
                << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::WaitingForRobotExit2ndFloorRobotDocked::Default()"
            << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "EXIT TRANSITION : MainMap::WaitingForRobotExit2ndFloorRobotDocked::Default()"
            << std::endl;
    }


}

void MainMap_WaitingForRobotExit2ndFloorRobotDocked::robotButtonReleased2ndFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotExit2ndFloorRobotDocked"
                << std::endl;
    }

    context.getState().Exit(context);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::WaitingForRobotExit2ndFloorRobotDocked::robotButtonReleased2ndFloor()"
            << std::endl;
    }

    context.clearState();
    try
    {
        ctxt.startUndockingTimer();
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::WaitingForRobotExit2ndFloorRobotDocked::robotButtonReleased2ndFloor()"
                << std::endl;
        }

        context.setState(MainMap::WaitingForRobotExit2ndFloorRobotUndocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotExit2ndFloorRobotUndocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotExit2ndFloorRobotUndocked::Default(RobotelevatorStatemachineContext& context)
{

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotExit2ndFloorRobotUndocked"
                << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::WaitingForRobotExit2ndFloorRobotUndocked::Default()"
            << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "EXIT TRANSITION : MainMap::WaitingForRobotExit2ndFloorRobotUndocked::Default()"
            << std::endl;
    }


}

void MainMap_WaitingForRobotExit2ndFloorRobotUndocked::robotButtonPressed2ndFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotExit2ndFloorRobotUndocked"
                << std::endl;
    }

    context.getState().Exit(context);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::WaitingForRobotExit2ndFloorRobotUndocked::robotButtonPressed2ndFloor()"
            << std::endl;
    }

    context.clearState();
    try
    {
        ctxt.cancelUndockingTimer();
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::WaitingForRobotExit2ndFloorRobotUndocked::robotButtonPressed2ndFloor()"
                << std::endl;
        }

        context.setState(MainMap::WaitingForRobotExit2ndFloorRobotDocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotExit2ndFloorRobotDocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotExit2ndFloorRobotUndocked::undockingTimePassed(RobotelevatorStatemachineContext& context, int undockingtimerId)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotExit2ndFloorRobotUndocked"
                << std::endl;
    }

    if (ctxt.getCurrentUndockingTimerId() == undockingtimerId)
    {
        context.getState().Exit(context);
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::WaitingForRobotExit2ndFloorRobotUndocked::undockingTimePassed(int undockingtimerId)"
                << std::endl;
        }

        // No actions.
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::WaitingForRobotExit2ndFloorRobotUndocked::undockingTimePassed(int undockingtimerId)"
                << std::endl;
        }

        context.setState(MainMap::Cleaning2ndFloor);
        context.getState().Entry(context);
    }
    else
    {
         MainMap_Default::undockingTimePassed(context, undockingtimerId);
    }

}

void MainMap_Cleaning2ndFloor::Default(RobotelevatorStatemachineContext& context)
{

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::Cleaning2ndFloor"
                << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::Cleaning2ndFloor::Default()"
            << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "EXIT TRANSITION : MainMap::Cleaning2ndFloor::Default()"
            << std::endl;
    }


}

void MainMap_Cleaning2ndFloor::robotButtonPressed2ndFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::Cleaning2ndFloor"
                << std::endl;
    }

    context.getState().Exit(context);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::Cleaning2ndFloor::robotButtonPressed2ndFloor()"
            << std::endl;
    }

    context.clearState();
    try
    {
        ctxt.startDockingTimer();
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::Cleaning2ndFloor::robotButtonPressed2ndFloor()"
                << std::endl;
        }

        context.setState(MainMap::WaitingForRobotEnter2ndFloorRobotDocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotEnter2ndFloorRobotDocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotEnter2ndFloorRobotDocked::Default(RobotelevatorStatemachineContext& context)
{

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotEnter2ndFloorRobotDocked"
                << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::WaitingForRobotEnter2ndFloorRobotDocked::Default()"
            << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "EXIT TRANSITION : MainMap::WaitingForRobotEnter2ndFloorRobotDocked::Default()"
            << std::endl;
    }


}

void MainMap_WaitingForRobotEnter2ndFloorRobotDocked::dockingTimePassed(RobotelevatorStatemachineContext& context, int dockingtimerId)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotEnter2ndFloorRobotDocked"
                << std::endl;
    }

    if (ctxt.getCurrentDockingTimerId() == dockingtimerId)
    {
        context.getState().Exit(context);
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::WaitingForRobotEnter2ndFloorRobotDocked::dockingTimePassed(int dockingtimerId)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.moveUp();
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::WaitingForRobotEnter2ndFloorRobotDocked::dockingTimePassed(int dockingtimerId)"
                    << std::endl;
            }

            context.setState(MainMap::MovingUpToParkingPosition);
        }
        catch (...)
        {
            context.setState(MainMap::MovingUpToParkingPosition);
            throw;
        }
        context.getState().Entry(context);
    }
    else
    {
         MainMap_Default::dockingTimePassed(context, dockingtimerId);
    }

}

void MainMap_WaitingForRobotEnter2ndFloorRobotDocked::robotButtonReleased2ndFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotEnter2ndFloorRobotDocked"
                << std::endl;
    }

    context.getState().Exit(context);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::WaitingForRobotEnter2ndFloorRobotDocked::robotButtonReleased2ndFloor()"
            << std::endl;
    }

    context.clearState();
    try
    {
        ctxt.cancelDockingTimer();
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::WaitingForRobotEnter2ndFloorRobotDocked::robotButtonReleased2ndFloor()"
                << std::endl;
        }

        context.setState(MainMap::Cleaning2ndFloor);
    }
    catch (...)
    {
        context.setState(MainMap::Cleaning2ndFloor);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_MovingDownTo1stFloor::Default(RobotelevatorStatemachineContext& context)
{

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::MovingDownTo1stFloor"
                << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::MovingDownTo1stFloor::Default()"
            << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "EXIT TRANSITION : MainMap::MovingDownTo1stFloor::Default()"
            << std::endl;
    }


}

void MainMap_MovingDownTo1stFloor::carrierButtonPressed1stFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::MovingDownTo1stFloor"
                << std::endl;
    }

    context.getState().Exit(context);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::MovingDownTo1stFloor::carrierButtonPressed1stFloor()"
            << std::endl;
    }

    context.clearState();
    try
    {
        ctxt.stop();
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::MovingDownTo1stFloor::carrierButtonPressed1stFloor()"
                << std::endl;
        }

        context.setState(MainMap::WaitingForRobotExit1stFloorRobotDocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotExit1stFloorRobotDocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotExit1stFloorRobotDocked::Default(RobotelevatorStatemachineContext& context)
{

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotExit1stFloorRobotDocked"
                << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::WaitingForRobotExit1stFloorRobotDocked::Default()"
            << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "EXIT TRANSITION : MainMap::WaitingForRobotExit1stFloorRobotDocked::Default()"
            << std::endl;
    }


}

void MainMap_WaitingForRobotExit1stFloorRobotDocked::robotButtonReleased1stFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotExit1stFloorRobotDocked"
                << std::endl;
    }

    context.getState().Exit(context);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::WaitingForRobotExit1stFloorRobotDocked::robotButtonReleased1stFloor()"
            << std::endl;
    }

    context.clearState();
    try
    {
        ctxt.startUndockingTimer();
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::WaitingForRobotExit1stFloorRobotDocked::robotButtonReleased1stFloor()"
                << std::endl;
        }

        context.setState(MainMap::WaitingForRobotExit1stFloorRobotUndocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotExit1stFloorRobotUndocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotExit1stFloorRobotUndocked::Default(RobotelevatorStatemachineContext& context)
{

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotExit1stFloorRobotUndocked"
                << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::WaitingForRobotExit1stFloorRobotUndocked::Default()"
            << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "EXIT TRANSITION : MainMap::WaitingForRobotExit1stFloorRobotUndocked::Default()"
            << std::endl;
    }


}

void MainMap_WaitingForRobotExit1stFloorRobotUndocked::robotButtonPressed1stFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotExit1stFloorRobotUndocked"
                << std::endl;
    }

    context.getState().Exit(context);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::WaitingForRobotExit1stFloorRobotUndocked::robotButtonPressed1stFloor()"
            << std::endl;
    }

    context.clearState();
    try
    {
        ctxt.cancelUndockingTimer();
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::WaitingForRobotExit1stFloorRobotUndocked::robotButtonPressed1stFloor()"
                << std::endl;
        }

        context.setState(MainMap::WaitingForRobotExit1stFloorRobotDocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotExit1stFloorRobotDocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotExit1stFloorRobotUndocked::undockingTimePassed(RobotelevatorStatemachineContext& context, int undockingtimerId)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotExit1stFloorRobotUndocked"
                << std::endl;
    }

    if (ctxt.getCurrentUndockingTimerId() == undockingtimerId)
    {
        context.getState().Exit(context);
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::WaitingForRobotExit1stFloorRobotUndocked::undockingTimePassed(int undockingtimerId)"
                << std::endl;
        }

        // No actions.
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::WaitingForRobotExit1stFloorRobotUndocked::undockingTimePassed(int undockingtimerId)"
                << std::endl;
        }

        context.setState(MainMap::Cleaning1stFloor);
        context.getState().Entry(context);
    }
    else
    {
         MainMap_Default::undockingTimePassed(context, undockingtimerId);
    }

}

void MainMap_Cleaning1stFloor::Default(RobotelevatorStatemachineContext& context)
{

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::Cleaning1stFloor"
                << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::Cleaning1stFloor::Default()"
            << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "EXIT TRANSITION : MainMap::Cleaning1stFloor::Default()"
            << std::endl;
    }


}

void MainMap_Cleaning1stFloor::robotButtonPressed1stFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::Cleaning1stFloor"
                << std::endl;
    }

    context.getState().Exit(context);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::Cleaning1stFloor::robotButtonPressed1stFloor()"
            << std::endl;
    }

    context.clearState();
    try
    {
        ctxt.startDockingTimer();
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::Cleaning1stFloor::robotButtonPressed1stFloor()"
                << std::endl;
        }

        context.setState(MainMap::WaitingForRobotEnter1stFloorRobotDocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotEnter1stFloorRobotDocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotEnter1stFloorRobotDocked::Default(RobotelevatorStatemachineContext& context)
{

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotEnter1stFloorRobotDocked"
                << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::WaitingForRobotEnter1stFloorRobotDocked::Default()"
            << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "EXIT TRANSITION : MainMap::WaitingForRobotEnter1stFloorRobotDocked::Default()"
            << std::endl;
    }


}

void MainMap_WaitingForRobotEnter1stFloorRobotDocked::dockingTimePassed(RobotelevatorStatemachineContext& context, int dockingtimerId)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotEnter1stFloorRobotDocked"
                << std::endl;
    }

    if (ctxt.getCurrentDockingTimerId() == dockingtimerId)
    {
        context.getState().Exit(context);
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::WaitingForRobotEnter1stFloorRobotDocked::dockingTimePassed(int dockingtimerId)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.moveUp();
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::WaitingForRobotEnter1stFloorRobotDocked::dockingTimePassed(int dockingtimerId)"
                    << std::endl;
            }

            context.setState(MainMap::MovingUpToParkingPosition);
        }
        catch (...)
        {
            context.setState(MainMap::MovingUpToParkingPosition);
            throw;
        }
        context.getState().Entry(context);
    }
    else
    {
         MainMap_Default::dockingTimePassed(context, dockingtimerId);
    }

}

void MainMap_WaitingForRobotEnter1stFloorRobotDocked::robotButtonReleased1stFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::WaitingForRobotEnter1stFloorRobotDocked"
                << std::endl;
    }

    context.getState().Exit(context);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::WaitingForRobotEnter1stFloorRobotDocked::robotButtonReleased1stFloor()"
            << std::endl;
    }

    context.clearState();
    try
    {
        ctxt.cancelDockingTimer();
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::WaitingForRobotEnter1stFloorRobotDocked::robotButtonReleased1stFloor()"
                << std::endl;
        }

        context.setState(MainMap::Cleaning1stFloor);
    }
    catch (...)
    {
        context.setState(MainMap::Cleaning1stFloor);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_MovingUpToParkingPosition::Default(RobotelevatorStatemachineContext& context)
{

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::MovingUpToParkingPosition"
                << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::MovingUpToParkingPosition::Default()"
            << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "EXIT TRANSITION : MainMap::MovingUpToParkingPosition::Default()"
            << std::endl;
    }


}

void MainMap_MovingUpToParkingPosition::carrierButtonPressedParkingPosition(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::MovingUpToParkingPosition"
                << std::endl;
    }

    context.getState().Exit(context);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::MovingUpToParkingPosition::carrierButtonPressedParkingPosition()"
            << std::endl;
    }

    context.clearState();
    try
    {
        ctxt.stop();
        ctxt.exit();
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::MovingUpToParkingPosition::carrierButtonPressedParkingPosition()"
                << std::endl;
        }

        context.setState(MainMap::Parked);
    }
    catch (...)
    {
        context.setState(MainMap::Parked);
        throw;
    }
    context.getState().Entry(context);

}

//
// Local variables:
//  buffer-read-only: t
// End:
//
