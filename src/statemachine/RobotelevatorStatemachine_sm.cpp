//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : RobotelevatorStatemachine.sm
//

#include "RobotelevatorStatemachine.h"
#include "src/statemachine/RobotelevatorStatemachine_sm.h"

using namespace statemap;

// Static class declarations.
MainMap_Parked MainMap::Parked("MainMap::Parked", 0);
MainMap_MovingDownTo2ndFloor MainMap::MovingDownTo2ndFloor("MainMap::MovingDownTo2ndFloor", 1);
MainMap_WaitingForRobotExit2ndFloorRobotDocked MainMap::WaitingForRobotExit2ndFloorRobotDocked("MainMap::WaitingForRobotExit2ndFloorRobotDocked", 2);
MainMap_WaitingForRobotExit2ndFloorRobotUndocked MainMap::WaitingForRobotExit2ndFloorRobotUndocked("MainMap::WaitingForRobotExit2ndFloorRobotUndocked", 3);
MainMap_Cleaning2ndFloor MainMap::Cleaning2ndFloor("MainMap::Cleaning2ndFloor", 4);
MainMap_WaitingForRobotEnter2ndFloorRobotDocked MainMap::WaitingForRobotEnter2ndFloorRobotDocked("MainMap::WaitingForRobotEnter2ndFloorRobotDocked", 5);
MainMap_MovingDownTo1stFloor MainMap::MovingDownTo1stFloor("MainMap::MovingDownTo1stFloor", 6);
MainMap_WaitingForRobotExit1stFloorRobotDocked MainMap::WaitingForRobotExit1stFloorRobotDocked("MainMap::WaitingForRobotExit1stFloorRobotDocked", 7);
MainMap_WaitingForRobotExit1stFloorRobotUndocked MainMap::WaitingForRobotExit1stFloorRobotUndocked("MainMap::WaitingForRobotExit1stFloorRobotUndocked", 8);
MainMap_Cleaning1stFloor MainMap::Cleaning1stFloor("MainMap::Cleaning1stFloor", 9);
MainMap_WaitingForRobotEnter1stFloorRobotDocked MainMap::WaitingForRobotEnter1stFloorRobotDocked("MainMap::WaitingForRobotEnter1stFloorRobotDocked", 10);
MainMap_MovingUpToParkingPosition MainMap::MovingUpToParkingPosition("MainMap::MovingUpToParkingPosition", 11);

void RobotelevatorStatemachineState::carrierButtonPressed1stFloor(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::carrierButtonPressed2ndFloor(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::carrierButtonPressedParkingPosition(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::dockingTimePassed(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::robotButtonPressed1stFloor(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::robotButtonPressed2ndFloor(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::robotButtonReleased1stFloor(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::robotButtonReleased2ndFloor(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::startCleanup(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::undockingTimePassed(RobotelevatorStatemachineContext& context)
{
    Default(context);
}

void RobotelevatorStatemachineState::Default(RobotelevatorStatemachineContext& context)
{
    throw (
        TransitionUndefinedException(
            context.getState().getName(),
            context.getTransition()));

}

void MainMap_Parked::Default(RobotelevatorStatemachineContext& context)
{


}

void MainMap_Parked::startCleanup(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.moveDown();
        context.setState(MainMap::MovingDownTo2ndFloor);
    }
    catch (...)
    {
        context.setState(MainMap::MovingDownTo2ndFloor);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_MovingDownTo2ndFloor::Default(RobotelevatorStatemachineContext& context)
{


}

void MainMap_MovingDownTo2ndFloor::carrierButtonPressed2ndFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.stop();
        context.setState(MainMap::WaitingForRobotExit2ndFloorRobotDocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotExit2ndFloorRobotDocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotExit2ndFloorRobotDocked::Default(RobotelevatorStatemachineContext& context)
{


}

void MainMap_WaitingForRobotExit2ndFloorRobotDocked::robotButtonReleased2ndFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.startUndockingTimer();
        context.setState(MainMap::WaitingForRobotExit2ndFloorRobotUndocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotExit2ndFloorRobotUndocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotExit2ndFloorRobotUndocked::Default(RobotelevatorStatemachineContext& context)
{


}

void MainMap_WaitingForRobotExit2ndFloorRobotUndocked::robotButtonPressed2ndFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.cancelUndockingTimer();
        context.setState(MainMap::WaitingForRobotExit2ndFloorRobotDocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotExit2ndFloorRobotDocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotExit2ndFloorRobotUndocked::undockingTimePassed(RobotelevatorStatemachineContext& context)
{

    context.getState().Exit(context);
    context.setState(MainMap::Cleaning2ndFloor);
    context.getState().Entry(context);

}

void MainMap_Cleaning2ndFloor::Default(RobotelevatorStatemachineContext& context)
{


}

void MainMap_Cleaning2ndFloor::robotButtonPressed2ndFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.startDockingTimer();
        context.setState(MainMap::WaitingForRobotEnter2ndFloorRobotDocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotEnter2ndFloorRobotDocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotEnter2ndFloorRobotDocked::Default(RobotelevatorStatemachineContext& context)
{


}

void MainMap_WaitingForRobotEnter2ndFloorRobotDocked::dockingTimePassed(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.moveDown();
        context.setState(MainMap::MovingDownTo1stFloor);
    }
    catch (...)
    {
        context.setState(MainMap::MovingDownTo1stFloor);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotEnter2ndFloorRobotDocked::robotButtonReleased2ndFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.cancelDockingTimer();
        context.setState(MainMap::Cleaning2ndFloor);
    }
    catch (...)
    {
        context.setState(MainMap::Cleaning2ndFloor);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_MovingDownTo1stFloor::Default(RobotelevatorStatemachineContext& context)
{


}

void MainMap_MovingDownTo1stFloor::carrierButtonPressed1stFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.stop();
        context.setState(MainMap::WaitingForRobotExit1stFloorRobotDocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotExit1stFloorRobotDocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotExit1stFloorRobotDocked::Default(RobotelevatorStatemachineContext& context)
{


}

void MainMap_WaitingForRobotExit1stFloorRobotDocked::robotButtonReleased2ndFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.startUndockingTimer();
        context.setState(MainMap::WaitingForRobotExit1stFloorRobotUndocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotExit1stFloorRobotUndocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotExit1stFloorRobotUndocked::Default(RobotelevatorStatemachineContext& context)
{


}

void MainMap_WaitingForRobotExit1stFloorRobotUndocked::robotButtonPressed1stFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.cancelUndockingTimer();
        context.setState(MainMap::WaitingForRobotExit1stFloorRobotDocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotExit1stFloorRobotDocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotExit1stFloorRobotUndocked::undockingTimePassed(RobotelevatorStatemachineContext& context)
{

    context.getState().Exit(context);
    context.setState(MainMap::Cleaning1stFloor);
    context.getState().Entry(context);

}

void MainMap_Cleaning1stFloor::Default(RobotelevatorStatemachineContext& context)
{


}

void MainMap_Cleaning1stFloor::robotButtonPressed1stFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.startDockingTimer();
        context.setState(MainMap::WaitingForRobotEnter1stFloorRobotDocked);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForRobotEnter1stFloorRobotDocked);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotEnter1stFloorRobotDocked::Default(RobotelevatorStatemachineContext& context)
{


}

void MainMap_WaitingForRobotEnter1stFloorRobotDocked::dockingTimePassed(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.moveUp();
        context.setState(MainMap::MovingUpToParkingPosition);
    }
    catch (...)
    {
        context.setState(MainMap::MovingUpToParkingPosition);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForRobotEnter1stFloorRobotDocked::robotButtonReleased1stFloor(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.cancelDockingTimer();
        context.setState(MainMap::Cleaning1stFloor);
    }
    catch (...)
    {
        context.setState(MainMap::Cleaning1stFloor);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_MovingUpToParkingPosition::Default(RobotelevatorStatemachineContext& context)
{


}

void MainMap_MovingUpToParkingPosition::carrierButtonPressedParkingPosition(RobotelevatorStatemachineContext& context)
{
    RobotelevatorStatemachine& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.stop();
        context.setState(MainMap::Parked);
    }
    catch (...)
    {
        context.setState(MainMap::Parked);
        throw;
    }
    context.getState().Entry(context);

}

//
// Local variables:
//  buffer-read-only: t
// End:
//
